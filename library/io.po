# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/PyCampES/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-05 12:54+0200\n"
"PO-Revision-Date: 2020-05-30 15:48-0400\n"
"Language-Team: python-doc-es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Last-Translator: Douglas Cueva <dougcueva@gmail.com>\n"
"Language: io\n"
"X-Generator: Poedit 2.3.1\n"

#: ../Doc/library/io.rst:2
msgid ":mod:`io` --- Core tools for working with streams"
msgstr ":mod:`io` — Herramientas principales para trabajar con transmisiones"

#: ../Doc/library/io.rst:15
msgid "**Source code:** :source:`Lib/io.py`"
msgstr "**Código fuente:** :source:`Lib/io.py`"

#: ../Doc/library/io.rst:22
msgid "Overview"
msgstr "Resumen"

#: ../Doc/library/io.rst:27
msgid ""
"The :mod:`io` module provides Python's main facilities for dealing with "
"various types of I/O.  There are three main types of I/O: *text I/O*, "
"*binary I/O* and *raw I/O*.  These are generic categories, and various "
"backing stores can be used for each of them.  A concrete object belonging to "
"any of these categories is called a :term:`file object`.  Other common terms "
"are *stream* and *file-like object*."
msgstr ""
"El módulo :mod:`io` provee las facilidades principales de Python para "
"manejar diferentes tipos de I/O. Hay tres diferentes tipos de I/O: *texto I/"
"O*, *binario I/O* e *I/O sin formato*. Estas son categorias generales y "
"varios respaldos de almacenamiento se pueden usar para cada una de ellas. Un "
"objeto concreto perteneciendo a cualquiera de estas categorias se llama un :"
"term:`file object`. Otros términos comunes son *stream* y *file-like object*."

#: ../Doc/library/io.rst:34
msgid ""
"Independent of its category, each concrete stream object will also have "
"various capabilities: it can be read-only, write-only, or read-write. It can "
"also allow arbitrary random access (seeking forwards or backwards to any "
"location), or only sequential access (for example in the case of a socket or "
"pipe)."
msgstr ""
"Independiente de su categoría, cada objeto de transmisión también tendrá "
"varias capacidades: puede ser solamente para lectura, solo escritura, or "
"lectura y escritura. También permite arbitriaramente acceso aleatorio "
"(buscando adelante o hacia atrás en cualquier lugar) o solamente acceso "
"sequencial (por ejemplo en el caso de un *socket* o *pipe*)."

#: ../Doc/library/io.rst:40
msgid ""
"All streams are careful about the type of data you give to them.  For "
"example giving a :class:`str` object to the ``write()`` method of a binary "
"stream will raise a :exc:`TypeError`.  So will giving a :class:`bytes` "
"object to the ``write()`` method of a text stream."
msgstr ""
"Todas las transmisiones son cuidadosas del tipo de datos que se les provee. "
"Por ejemplo dando un objeto de clase class:`str` al método ``write()`` de "
"una transmisión binaria levantará un :exc:`TypeError`. También dándole un "
"objeto de tipo :class:`bytes` al método ``write()`` de una transmisión de "
"tipo texto."

#: ../Doc/library/io.rst:45
msgid ""
"Operations that used to raise :exc:`IOError` now raise :exc:`OSError`, "
"since :exc:`IOError` is now an alias of :exc:`OSError`."
msgstr ""
"Operaciones que levantaban un :exc:`IOError`ahora levantan :exc:`OSError`, "
"ya que :exc:`IOError` es un alias de :exc:`OSError`."

#: ../Doc/library/io.rst:51 ../Doc/library/io.rst:777
#: ../Doc/library/io.rst:1032
msgid "Text I/O"
msgstr "I/O Texto"

#: ../Doc/library/io.rst:53
msgid ""
"Text I/O expects and produces :class:`str` objects.  This means that "
"whenever the backing store is natively made of bytes (such as in the case of "
"a file), encoding and decoding of data is made transparently as well as "
"optional translation of platform-specific newline characters."
msgstr ""
"I/O de tipo texto espera y produce objetos de clase :class:`str`. Esto "
"significa que cuando el respaldo de almacenamiento está compuesto "
"nativamente de *bytes* (como en el caso de un archivo), la codificación y "
"descodificación de datos está hecho transparentemente tanto como traducción "
"opcional de caracteres de nueva línea específicos de la plataforma."

#: ../Doc/library/io.rst:58
msgid ""
"The easiest way to create a text stream is with :meth:`open()`, optionally "
"specifying an encoding::"
msgstr ""
"La manera más fácil de crear una transmisión de tipo texto es con el método :"
"meth:`open()`, con la opción de especificar una codificación::"

#: ../Doc/library/io.rst:63
msgid ""
"In-memory text streams are also available as :class:`StringIO` objects::"
msgstr ""
"Transmisiones de texto en memoria también están disponibles como objetos de "
"tipo :class:`StringIO`::"

#: ../Doc/library/io.rst:67
msgid ""
"The text stream API is described in detail in the documentation of :class:"
"`TextIOBase`."
msgstr ""
"El *API* (interfaz de programación de aplicaciones) de transmisiones tipo "
"texto está descrito con detalle en la documentación de :class:`TextIOBase`."

#: ../Doc/library/io.rst:72 ../Doc/library/io.rst:1020
msgid "Binary I/O"
msgstr "I/O Binaria"

# I’m not sure if I have to translate the <bytes-like object> link
#: ../Doc/library/io.rst:74
msgid ""
"Binary I/O (also called *buffered I/O*) expects :term:`bytes-like objects "
"<bytes-like object>` and produces :class:`bytes` objects.  No encoding, "
"decoding, or newline translation is performed.  This category of streams can "
"be used for all kinds of non-text data, and also when manual control over "
"the handling of text data is desired."
msgstr ""
"I/O binaria (también conocido como *buffered I/O*) espera :term:`objetos "
"tipo bytes<bytes-like object>` y produce objetos tipo :class:`bytes`. No se "
"hace codificación, descodificación, o traduciones de nueva línea. Esta "
"categoría de transmisiones puede ser usada para todos tipos de datos sin "
"texto, y también cuando se desea control manual sobre el manejo de dato "
"textual."

#: ../Doc/library/io.rst:80
msgid ""
"The easiest way to create a binary stream is with :meth:`open()` with "
"``'b'`` in the mode string::"
msgstr ""
"La manera más fácil para crear una transmisión binaria es con el método :"
"meth:`open()` con ``’b’`` en el modo de la cadena de caracteres::"

#: ../Doc/library/io.rst:85
msgid ""
"In-memory binary streams are also available as :class:`BytesIO` objects::"
msgstr ""
"Las transmisiones binarias en memoria también están disponibles como objetos "
"tipo :class:`BytesIO`::"

#: ../Doc/library/io.rst:89
msgid ""
"The binary stream API is described in detail in the docs of :class:"
"`BufferedIOBase`."
msgstr ""
"El *API* de transmisión binario está descrito con detalle en la "
"documentación de :class:`BufferedIOBase`."

#: ../Doc/library/io.rst:92
msgid ""
"Other library modules may provide additional ways to create text or binary "
"streams.  See :meth:`socket.socket.makefile` for example."
msgstr ""
"Otros módulos bibliotecarios pueden proveer maneras alternativas para crear "
"transmisiones de tipo texto o binario. Ver :meth:`socket.socket.makefile` "
"como ejemplo."

#: ../Doc/library/io.rst:97
msgid "Raw I/O"
msgstr "I/O sin formato"

#: ../Doc/library/io.rst:99
msgid ""
"Raw I/O (also called *unbuffered I/O*) is generally used as a low-level "
"building-block for binary and text streams; it is rarely useful to directly "
"manipulate a raw stream from user code.  Nevertheless, you can create a raw "
"stream by opening a file in binary mode with buffering disabled::"
msgstr ""
"I/O sin formato (también conocido como *unbuffered I/O*) es generalment "
"usado como un fundamento de nivel bajo para transmisiones binario y tipo "
"texto; es raramente útil para manipular directamente transmisiones sin "
"formatos del código de usuario. Sin embargo puedes crear una transmisión sin "
"formato abriendo un archivo en modo binario con el búfer apagado::"

#: ../Doc/library/io.rst:106
msgid ""
"The raw stream API is described in detail in the docs of :class:`RawIOBase`."
msgstr ""
"El *API* de transmisiones sin formato está descrito con detalle en la "
"documentación de :class:`RawIOBase`."

#: ../Doc/library/io.rst:110
msgid "High-level Module Interface"
msgstr "Interfaz de módulo de alto nivel"

#: ../Doc/library/io.rst:114
msgid ""
"An int containing the default buffer size used by the module's buffered I/O "
"classes.  :func:`open` uses the file's blksize (as obtained by :func:`os."
"stat`) if possible."
msgstr ""
"Un *int* que contiene el búfer de tamaño predeterminado usado por las clases "
"de tipo I/O. :func:`open` utiliza el blksize del archivo (obtenido por :func:"
"`os.stat`) si es posible."

#: ../Doc/library/io.rst:121
msgid "This is an alias for the builtin :func:`open` function."
msgstr "Esto es un alias para la función incorporada :func:`open`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``open`` with arguments ``path``, "
"``mode``, ``flags``."
msgstr ""
"Lanza un :ref:`auditing event <auditing>` ``open`` con los "
"argumentos``path``, ``mode``, ``flags``."

#: ../Doc/library/io.rst:125
msgid ""
"This function raises an :ref:`auditing event <auditing>` ``open`` with "
"arguments ``path``, ``mode`` and ``flags``. The ``mode`` and ``flags`` "
"arguments may have been modified or inferred from the original call."
msgstr ""
"Esta función lanza un ref:`auditing event <auditing>` ``open`` con los "
"argumentos ``path``, ``mode`` y ``flags``. Los argumentos``mode`` y "
"``flags`` pueden haber sido modificados o inferido desde el pedido original."

#: ../Doc/library/io.rst:132
msgid ""
"Opens the provided file with mode ``'rb'``. This function should be used "
"when the intent is to treat the contents as executable code."
msgstr ""
"Esto abre el archivo dado con el modo ``’rb’``. Esta función debe ser usado "
"caundo la intención es tratar el contenido como código ejecutible."

#: ../Doc/library/io.rst:135
msgid "``path`` should be a :class:`str` and an absolute path."
msgstr "``path`` debe ser un :class:`str` y una ruta absoluta."

#: ../Doc/library/io.rst:137
msgid ""
"The behavior of this function may be overridden by an earlier call to the :c:"
"func:`PyFile_SetOpenCodeHook`. However, assuming that ``path`` is a :class:"
"`str` and an absolute path, ``open_code(path)`` should always behave the "
"same as ``open(path, 'rb')``. Overriding the behavior is intended for "
"additional validation or preprocessing of the file."
msgstr ""
"Se puede anular el comportamiento de esta función haciendo un pedido "
"anterior a :c:func:`PyFile_SetOpenCodeHook`. Sin embargo, asumiendo que "
"``path`` es un :class:`str` y una ruta absoluta, ``open_code(path)`` debería "
"manejarse al igual que ``open(path, ‘rb’)``. El propósito de anular el "
"comportamiento existe para validación adicional o para el preprocesamiento "
"del archivo."

#: ../Doc/library/io.rst:148
msgid ""
"This is a compatibility alias for the builtin :exc:`BlockingIOError` "
"exception."
msgstr ""
"Esto es un alias de compatibilidad para la incorporada excepción :exc:"
"`BlockingIOError`."

#: ../Doc/library/io.rst:154
msgid ""
"An exception inheriting :exc:`OSError` and :exc:`ValueError` that is raised "
"when an unsupported operation is called on a stream."
msgstr ""
"Una excepción heredando :exc:`OSError` y :exc:`ValueError` que es generado "
"cuando se llama a una operación no admitida en una transmisión."

#: ../Doc/library/io.rst:159
msgid "In-memory streams"
msgstr "Transmisiones en memoria"

#: ../Doc/library/io.rst:161
msgid ""
"It is also possible to use a :class:`str` or :term:`bytes-like object` as a "
"file for both reading and writing.  For strings :class:`StringIO` can be "
"used like a file opened in text mode.  :class:`BytesIO` can be used like a "
"file opened in binary mode.  Both provide full read-write capabilities with "
"random access."
msgstr ""
"Es posible usar un :class:`str` o :term:`bytes-like object` como un archivo "
"para lectura y escritura. Para cadena de caracteres :class:`StringIO` pueden "
"ser usados como un archivo abierto en modo texto. :class:`BytesIO` puede ser "
"usado como un archivo abierto in modo binario. Ambos proveen completa "
"capacidada para lectura y escritura con acceso aleatorio."

#: ../Doc/library/io.rst:171
msgid ":mod:`sys`"
msgstr ":mod:`sys`"

#: ../Doc/library/io.rst:171
msgid ""
"contains the standard IO streams: :data:`sys.stdin`, :data:`sys.stdout`, "
"and :data:`sys.stderr`."
msgstr ""
"contiene las transmisiones estándar de IO :data:`sys.stdin`, :data:`sys."
"stdout`, y :data:`sys.stderr`."

#: ../Doc/library/io.rst:176
msgid "Class hierarchy"
msgstr "Jerarquía de clases"

#: ../Doc/library/io.rst:178
msgid ""
"The implementation of I/O streams is organized as a hierarchy of classes.  "
"First :term:`abstract base classes <abstract base class>` (ABCs), which are "
"used to specify the various categories of streams, then concrete classes "
"providing the standard stream implementations."
msgstr ""
"La implementación de transmisiones I/O está organizada como una jerarquía de "
"clases. Primero :term:`abstract base classes <abstract base class>` (ABC), "
"que son usados para espicificar las varias categorias de transmisiones, "
"luego las clases concretas proveen la transmisión estándar de "
"implementaciones."

#: ../Doc/library/io.rst:185
msgid ""
"The abstract base classes also provide default implementations of some "
"methods in order to help implementation of concrete stream classes.  For "
"example, :class:`BufferedIOBase` provides unoptimized implementations of :"
"meth:`~IOBase.readinto` and :meth:`~IOBase.readline`."
msgstr ""
"Las clases abstractas base también proveen implementaciones predeterminadas "
"de algunos métodos para ayudar implementar clases de transmisiones "
"concretos. Por ejemplo, :class:`BufferedIOBase` proporciona implementaciones "
"no optimizadas de :meth:`~IOBase.readinto` y :meth:`~IOBase.readline`."

#: ../Doc/library/io.rst:190
msgid ""
"At the top of the I/O hierarchy is the abstract base class :class:`IOBase`.  "
"It defines the basic interface to a stream.  Note, however, that there is no "
"separation between reading and writing to streams; implementations are "
"allowed to raise :exc:`UnsupportedOperation` if they do not support a given "
"operation."
msgstr ""
"En la parte superior de la jerarquía I/O está la clase abstracta base :class:"
"`IOBase`. Define la interfaz básica de la transmisión. Tenga en cuenta que "
"no hay separación entre transmisiones de lectura y escritura; "
"implementaciones están permitidos lanzar :exc:`UnsupportedOperation` si no "
"apoyan la operación."

#: ../Doc/library/io.rst:195
msgid ""
"The :class:`RawIOBase` ABC extends :class:`IOBase`.  It deals with the "
"reading and writing of bytes to a stream.  :class:`FileIO` subclasses :class:"
"`RawIOBase` to provide an interface to files in the machine's file system."
msgstr ""
"La clase :class:`RawIOBase` extiende :class:`IOBase`. Maneja la lectura y "
"escritura de bytes a una transmisión. :class:`FileIO` subclasifica :class:"
"`RawIOBase` para proveer una interfaz a los archivos en el sistema de "
"archivos de la máquina."

#: ../Doc/library/io.rst:199
msgid ""
"The :class:`BufferedIOBase` ABC deals with buffering on a raw byte stream (:"
"class:`RawIOBase`).  Its subclasses, :class:`BufferedWriter`, :class:"
"`BufferedReader`, and :class:`BufferedRWPair` buffer streams that are "
"readable, writable, and both readable and writable.  :class:`BufferedRandom` "
"provides a buffered interface to random access streams.  Another :class:"
"`BufferedIOBase` subclass, :class:`BytesIO`, is a stream of in-memory bytes."
msgstr ""
"La :class:`BufferedIOBase` ABC maneja el búfer en una transmisión de *bytes* "
"sin formato (:class:`RawIOBase`). Sus subclasificaciones, :class:"
"`BufferedWriter`, :class:`BufferedReader`, y :class:`BufferedRWPair` "
"transmisiones de búfer que son legible, grabable, y ambos legible y "
"grabable.  :class:`BufferedRandom` provee un interfaz búfer a transmisiones "
"de acceso aleatorio. Otra subclasificación :class:`BufferedIOBase`, :class:"
"`BytesIO`, es una transmisión de *bytes* en memoria."

#: ../Doc/library/io.rst:207
msgid ""
"The :class:`TextIOBase` ABC, another subclass of :class:`IOBase`, deals with "
"streams whose bytes represent text, and handles encoding and decoding to and "
"from strings. :class:`TextIOWrapper`, which extends it, is a buffered text "
"interface to a buffered raw stream (:class:`BufferedIOBase`). Finally, :"
"class:`StringIO` is an in-memory stream for text."
msgstr ""
"El :class:`TextIOBase` ABC, otra subclasificación de :class:`IOBase`, trata "
"con las transmisiones cuyos *bytes* representan texto, y maneja la "
"codificación y descodificación para cadenas de cracteres y de estos mismos. :"
"class:`TextIOWrapper`, que extiende a este, es un interfaz textual "
"almacenado una transmisión sin formato amortiguado (:class:"
"`BufferedIOBase`). Finalmente, :class:`StringIO`  es una transmisión en "
"memoria para texto."

#: ../Doc/library/io.rst:213
msgid ""
"Argument names are not part of the specification, and only the arguments of :"
"func:`open` are intended to be used as keyword arguments."
msgstr ""
"Los nombres de los argument no son parte de la especificación, y solo los "
"argumentos de :func:`open` están destinados a ser utilizados como argumentos "
"de palabras clave."

#: ../Doc/library/io.rst:216
msgid ""
"The following table summarizes the ABCs provided by the :mod:`io` module:"
msgstr ""
"La siguiente tabla resume los ABC proporcionado por el módulo :mod:`io` "
"module:"

#: ../Doc/library/io.rst:221
msgid "ABC"
msgstr "ABC"

#: ../Doc/library/io.rst:221
msgid "Inherits"
msgstr "Hereda"

#: ../Doc/library/io.rst:221
msgid "Stub Methods"
msgstr "Métodos de trozos"

#: ../Doc/library/io.rst:221
msgid "Mixin Methods and Properties"
msgstr "Métodos de mezcla y propiedades"

#: ../Doc/library/io.rst:223 ../Doc/library/io.rst:228
#: ../Doc/library/io.rst:230 ../Doc/library/io.rst:232
msgid ":class:`IOBase`"
msgstr ":class:`IOBase`"

#: ../Doc/library/io.rst:223
msgid "``fileno``, ``seek``, and ``truncate``"
msgstr "``fileno``, ``seek``, and ``truncate``"

#: ../Doc/library/io.rst:223
msgid ""
"``close``, ``closed``, ``__enter__``, ``__exit__``, ``flush``, ``isatty``, "
"``__iter__``, ``__next__``, ``readable``, ``readline``, ``readlines``, "
"``seekable``, ``tell``, ``writable``, and ``writelines``"
msgstr ""
"``close``, ``closed``, ``__enter__``, ``__exit__``, ``flush``, ``isatty``, "
"``__iter__``, ``__next__``, ``readable``, ``readline``, ``readlines``, "
"``seekable``, ``tell``, ``writable``, and ``writelines``"

#: ../Doc/library/io.rst:228
msgid ":class:`RawIOBase`"
msgstr ":class:`RawIOBase`"

#: ../Doc/library/io.rst:228
msgid "``readinto`` and ``write``"
msgstr "``readinto`` and ``write``"

#: ../Doc/library/io.rst:228
msgid "Inherited :class:`IOBase` methods, ``read``, and ``readall``"
msgstr "Inherited :class:`IOBase` methods, ``read``, and ``readall``"

#: ../Doc/library/io.rst:230
msgid ":class:`BufferedIOBase`"
msgstr ":class:`BufferedIOBase`"

#: ../Doc/library/io.rst:230
msgid "``detach``, ``read``, ``read1``, and ``write``"
msgstr "``detach``, ``read``, ``read1``, and ``write``"

#: ../Doc/library/io.rst:230
msgid "Inherited :class:`IOBase` methods, ``readinto``, and ``readinto1``"
msgstr "Inherited :class:`IOBase` methods, ``readinto``, and ``readinto1``"

#: ../Doc/library/io.rst:232
msgid ":class:`TextIOBase`"
msgstr ":class:`TextIOBase`"

#: ../Doc/library/io.rst:232
msgid "``detach``, ``read``, ``readline``, and ``write``"
msgstr "``detach``, ``read``, ``readline``, and ``write``"

#: ../Doc/library/io.rst:232
msgid ""
"Inherited :class:`IOBase` methods, ``encoding``, ``errors``, and ``newlines``"
msgstr ""
"Inherited :class:`IOBase` methods, ``encoding``, ``errors``, and ``newlines``"

#: ../Doc/library/io.rst:239
msgid "I/O Base Classes"
msgstr "Clases base I/O"

#: ../Doc/library/io.rst:243
msgid ""
"The abstract base class for all I/O classes, acting on streams of bytes. "
"There is no public constructor."
msgstr ""
"La clase base abstracta para todas las clases de tipo I/O, actuando sobre "
"transmisiones de *bytes*. No hay constructor público."

#: ../Doc/library/io.rst:246
msgid ""
"This class provides empty abstract implementations for many methods that "
"derived classes can override selectively; the default implementations "
"represent a file that cannot be read, written or seeked."
msgstr ""
"Esta clase provee implementaciones abstractas vacías para muchos métodos que "
"clases que derivadas pueden anular selectivamente; la implementación "
"predeterminada representa un archivo que no se puede leer, grabar o ser "
"buscado."

#: ../Doc/library/io.rst:251
msgid ""
"Even though :class:`IOBase` does not declare :meth:`read` or :meth:`write` "
"because their signatures will vary, implementations and clients should "
"consider those methods part of the interface.  Also, implementations may "
"raise a :exc:`ValueError` (or :exc:`UnsupportedOperation`) when operations "
"they do not support are called."
msgstr ""
"Aunque :class:`IOBase` no declara el método :meth:`read` o :meth:`write` "
"porque sus firmas varían, implementaciones y clientes deberían considerar "
"usar métodos como parte de la interfaz. Las implementaciones también podrían "
"lanzar un :exc:`ValueError` (o :exc:`UnsupportedOperation`) cuando "
"operaciones que estos no apoyan son usados."

#: ../Doc/library/io.rst:257
msgid ""
"The basic type used for binary data read from or written to a file is :class:"
"`bytes`.  Other :term:`bytes-like objects <bytes-like object>` are accepted "
"as method arguments too.  Text I/O classes work with :class:`str` data."
msgstr ""
"El tipo básico usado para leer datos binarios o grabar un archivo es :class:"
"`bytes`. Otros :term:`bytes-like objects <bytes-like object>` son aceptados "
"como argumentos para métodos también. Clases de tipo I/O funcionan usando "
"datos de tipo :class:`str`."

#: ../Doc/library/io.rst:261
msgid ""
"Note that calling any method (even inquiries) on a closed stream is "
"undefined.  Implementations may raise :exc:`ValueError` in this case."
msgstr ""
"Tenga en cuenta que llamando qualquier método (incluso indagaciones) en una "
"transmisión cerrada es indefinido. En este caso implementaciones podrían "
"lanzar un error :exc:`ValueError`."

#: ../Doc/library/io.rst:264
msgid ""
":class:`IOBase` (and its subclasses) supports the iterator protocol, meaning "
"that an :class:`IOBase` object can be iterated over yielding the lines in a "
"stream.  Lines are defined slightly differently depending on whether the "
"stream is a binary stream (yielding bytes), or a text stream (yielding "
"character strings).  See :meth:`~IOBase.readline` below."
msgstr ""
":class:`IOBase` (y sus subcalsificaciones) apoyan el protocolo iterador, "
"significando que un objeto de clase :class:`IOBase` puede ser iterado sobre "
"el rendimiento de las líneas en una transmisión de datos. Líneas son "
"definidas un poco diferente dependiendo si la transmisión es de tipo binario "
"(produciendo *bytes*), o una transmisión de texto (produciendo cadenas de "
"caracteres). Ver :meth:`~IOBase.readline` abajo."

#: ../Doc/library/io.rst:270
msgid ""
":class:`IOBase` is also a context manager and therefore supports the :"
"keyword:`with` statement.  In this example, *file* is closed after the :"
"keyword:`!with` statement's suite is finished---even if an exception occurs::"
msgstr ""
":class:`IOBase` es también un gestor de context y por ende apoya la "
"declaración :keyword:`with`. En este ejemplo, *file* es cerrado después de "
"que la declaración :keyword:`!with` termina—incluso si alguna excepción "
"ocurre::"

#: ../Doc/library/io.rst:277
msgid ":class:`IOBase` provides these data attributes and methods:"
msgstr ":class:`IOBase` provee los siguientes atributos y métodos:"

#: ../Doc/library/io.rst:281
msgid ""
"Flush and close this stream. This method has no effect if the file is "
"already closed. Once the file is closed, any operation on the file (e.g. "
"reading or writing) will raise a :exc:`ValueError`."
msgstr ""
"Cierra la transmisión. Este método no tiene efecto si el archivo ya está "
"cerrado. Cuándo está cerrado, cualquier operación que se le haga al archivo "
"(ej. leer or grabar) lanzará el error :exc:`ValueError`."

#: ../Doc/library/io.rst:285
msgid ""
"As a convenience, it is allowed to call this method more than once; only the "
"first call, however, will have an effect."
msgstr ""
"Como convenienca, se permite llamar este método más que una vez. Sin "
"embargo, solamente el primer llamado tenderá efecto."

#: ../Doc/library/io.rst:290
msgid "``True`` if the stream is closed."
msgstr "``True`` si está cerrada la transmisión."

#: ../Doc/library/io.rst:294
msgid ""
"Return the underlying file descriptor (an integer) of the stream if it "
"exists.  An :exc:`OSError` is raised if the IO object does not use a file "
"descriptor."
msgstr ""
"Devuelve el descriptor de archivo subyacente (un número de tipo entero) de "
"la transmisión si existe. Un :exc:`OSError` se lanza si el objeto IO no "
"tiene un archivo descriptor."

#: ../Doc/library/io.rst:300
msgid ""
"Flush the write buffers of the stream if applicable.  This does nothing for "
"read-only and non-blocking streams."
msgstr ""
"Vacía los buffers de grabación de la transmisión si corresponde. Esto no "
"hace nada para transmisiones que son solamente de lectura o transmisiones "
"sin bloqueo."

#: ../Doc/library/io.rst:305
msgid ""
"Return ``True`` if the stream is interactive (i.e., connected to a terminal/"
"tty device)."
msgstr ""
"Devuelve ``True``  si la transmisión es interactiva (ej., si está conectado "
"a un terminal o dispositivo tty)."

#: ../Doc/library/io.rst:310
msgid ""
"Return ``True`` if the stream can be read from.  If ``False``, :meth:`read` "
"will raise :exc:`OSError`."
msgstr ""
"Devuelve ``True`` si la transmisión puede ser leída. Si es ``False``, el "
"método :meth:`read`  lanzará un :exc:`OSError`."

#: ../Doc/library/io.rst:315
msgid ""
"Read and return one line from the stream.  If *size* is specified, at most "
"*size* bytes will be read."
msgstr ""
"Leer y devolver una línea de la transmisión. Si *size* (tamaño) es "
"especificado, se capturará un máximo de ése mismo tamaño especificado en "
"*bytes*."

#: ../Doc/library/io.rst:318
msgid ""
"The line terminator is always ``b'\\n'`` for binary files; for text files, "
"the *newline* argument to :func:`open` can be used to select the line "
"terminator(s) recognized."
msgstr ""
"El terminador de la línea siempre es ``b’\\n’`` para archivos de tipo "
"binario; para archivos de tipo texto el argumento *newline* para la función :"
"func:`open` pueden ser usados para selecionar las líneas terminadoras "
"reconocidas."

#: ../Doc/library/io.rst:324
msgid ""
"Read and return a list of lines from the stream.  *hint* can be specified to "
"control the number of lines read: no more lines will be read if the total "
"size (in bytes/characters) of all lines so far exceeds *hint*."
msgstr ""
"Leer y devolver una lista de líneas de la transmisión. *hint* puede ser "
"especificado para controlar el número de líneas que se lee: no se leerán más "
"líneas si el tamaño total (en *bytes* / caracteres) de todas las líneas "
"excede *hint*."

#: ../Doc/library/io.rst:328
msgid ""
"Note that it's already possible to iterate on file objects using ``for line "
"in file: ...`` without calling ``file.readlines()``."
msgstr ""
"Tenga en cuenta que ya es posible iterar sobre objetos de archivo usando "
"``for line in file: …`` sin llamar ``file.readlines()``."

#: ../Doc/library/io.rst:333
msgid ""
"Change the stream position to the given byte *offset*.  *offset* is "
"interpreted relative to the position indicated by *whence*.  The default "
"value for *whence* is :data:`SEEK_SET`.  Values for *whence* are:"
msgstr ""
"Cambiar la posición de la transmisión al dado *byte* *offset*. *offset* se "
"interpreta en relación con la posición indicada por *whence*. El valor dado "
"para *whence* es :data:`SEEK_SET`. Valores para *whence* son:"

#: ../Doc/library/io.rst:337
msgid ""
":data:`SEEK_SET` or ``0`` -- start of the stream (the default); *offset* "
"should be zero or positive"
msgstr ""
":data:`SEEK_SET` o ``0`` — inicio de la transmisión (el dado); *offset* "
"debería ser cero o positivo"

#: ../Doc/library/io.rst:339
msgid ""
":data:`SEEK_CUR` or ``1`` -- current stream position; *offset* may be "
"negative"
msgstr ""
":data:`SEEK_CUR` o ``1`` — posición actual de la transmisión; *offset* puede "
"ser negativo"

#: ../Doc/library/io.rst:341
msgid ""
":data:`SEEK_END` or ``2`` -- end of the stream; *offset* is usually negative"
msgstr ""
":data:`SEEK_END` o ``2`` — fin de la transmisión; *offset* is usualmente "
"negativo"

#: ../Doc/library/io.rst:344
msgid "Return the new absolute position."
msgstr "Devuelve la nueva posición absoluta."

#: ../Doc/library/io.rst:346 ../Doc/library/io.rst:853
msgid "The ``SEEK_*`` constants."
msgstr "Los constantes``SEEK_*``."

#: ../Doc/library/io.rst:349
msgid ""
"Some operating systems could support additional values, like :data:`os."
"SEEK_HOLE` or :data:`os.SEEK_DATA`. The valid values for a file could depend "
"on it being open in text or binary mode."
msgstr ""
"Algunos sistemas operativos pueden apoyar valores adicionales, como :data:"
"`os.SEEK_HOLE` o :data:`os.SEEK_DATA`. Los valores válidos para un archivo "
"podrían depender de que esté abierto en modo texto o binario."

#: ../Doc/library/io.rst:356
msgid ""
"Return ``True`` if the stream supports random access.  If ``False``, :meth:"
"`seek`, :meth:`tell` and :meth:`truncate` will raise :exc:`OSError`."
msgstr ""
"Devolver ``True`` si la transmisión apoya acceso aleatorio. Si devuelve "
"``False``, :meth:`seek`, :meth:`tell` y :meth:`truncate`  lanzarán :exc:"
"`OSError`."

#: ../Doc/library/io.rst:361
msgid "Return the current stream position."
msgstr "Devuelve la posición actual de la transmisión."

#: ../Doc/library/io.rst:365
msgid ""
"Resize the stream to the given *size* in bytes (or the current position if "
"*size* is not specified).  The current stream position isn't changed. This "
"resizing can extend or reduce the current file size.  In case of extension, "
"the contents of the new file area depend on the platform (on most systems, "
"additional bytes are zero-filled).  The new file size is returned."
msgstr ""
"Cambiar el tamaño de la transmisión al *size* dado en *bytes* (o la posición "
"actual si no se especifica *size*). La posición actual de la transmisión no "
"se cambia. Este cambio de tamaño puede incrementar o reducir el tamaño "
"actual del archivo. En caso de incrementación los contenidos del área del "
"nuevo archivo depende de la plataforma (en la mayoría de los sistemas "
"*bytes* adicionales son llenos de cero). Se devuelve el nuevo tamaño del "
"archivo."

#: ../Doc/library/io.rst:372
msgid "Windows will now zero-fill files when extending."
msgstr "*Windows* llenará los archivos con cero cuando extienda."

#: ../Doc/library/io.rst:377
msgid ""
"Return ``True`` if the stream supports writing.  If ``False``, :meth:`write` "
"and :meth:`truncate` will raise :exc:`OSError`."
msgstr ""
"Devolver ``True`` si la transmisión apoya grabación.  Si devuelve "
"``False``, :meth:`write` y :meth:`truncate` lanzarán :exc:`OSError`."

#: ../Doc/library/io.rst:382
msgid ""
"Write a list of lines to the stream.  Line separators are not added, so it "
"is usual for each of the lines provided to have a line separator at the end."
msgstr ""
"Escribir una lista de líneas a la transmisión. No se agrega separadores de "
"líneas, asi que es usual que las líneas tengan separador al final."

#: ../Doc/library/io.rst:388
msgid ""
"Prepare for object destruction. :class:`IOBase` provides a default "
"implementation of this method that calls the instance's :meth:`~IOBase."
"close` method."
msgstr ""
"Preparar para la destrucción de un objeto. :class:`IOBase` proporciona una "
"implementación dada de este método que ejecuta las instancias del método :"
"meth:`~IOBase.close`."

#: ../Doc/library/io.rst:395
msgid ""
"Base class for raw binary I/O.  It inherits :class:`IOBase`.  There is no "
"public constructor."
msgstr ""
"Clase base para binarios de tipo I/O sin formato. Hereda la clase :class:"
"`IOBase`. No hay constructor público."

#: ../Doc/library/io.rst:398
msgid ""
"Raw binary I/O typically provides low-level access to an underlying OS "
"device or API, and does not try to encapsulate it in high-level primitives "
"(this is left to Buffered I/O and Text I/O, described later in this page)."
msgstr ""
"I/O binario sin formato proporciona acceso de nivel bajo a algún dispositivo "
"del sistema operativo o API, y no intenta de encapsular primitivos de alto "
"nivel (esta función se le deja a I/O de tipo búfer y I/O de tipo texto; esto "
"se describe más adelante)."

#: ../Doc/library/io.rst:402
msgid ""
"In addition to the attributes and methods from :class:`IOBase`, :class:"
"`RawIOBase` provides the following methods:"
msgstr ""
"Además de los atributos y métodos de :class:`IOBase`, la clase :class:"
"`RawIOBase` proporciona los siguientes métodos:"

#: ../Doc/library/io.rst:407
msgid ""
"Read up to *size* bytes from the object and return them.  As a convenience, "
"if *size* is unspecified or -1, all bytes until EOF are returned. Otherwise, "
"only one system call is ever made.  Fewer than *size* bytes may be returned "
"if the operating system call returns fewer than *size* bytes."
msgstr ""
"Leer hasta el *size* de los *bytes* del objeto y devolverlos. Como "
"conveniencia si no se especifica *size* o es -1, se devuelven todos los "
"*bytes* hasta que se devuelva el fin del archivo. Sino, se hace solo un "
"llamado al sistema. Se pueden devolver menos de *size* *bytes* si la llamada "
"del sistema operativo devuelve menos de *size* *bytes*."

#: ../Doc/library/io.rst:412
msgid ""
"If 0 bytes are returned, and *size* was not 0, this indicates end of file. "
"If the object is in non-blocking mode and no bytes are available, ``None`` "
"is returned."
msgstr ""
"Si se devuelve 0 *bytes* y el *size* no era 0, esto indica que es el fin del "
"archivo. Si el objeto está en modo sin bloqueo y no hay *bytes* disponibles, "
"se devuelve ``None``."

#: ../Doc/library/io.rst:416
msgid ""
"The default implementation defers to :meth:`readall` and :meth:`readinto`."
msgstr ""
"La implementación dada difiera al método :meth:`readall` y :meth:`readinto`."

#: ../Doc/library/io.rst:421
msgid ""
"Read and return all the bytes from the stream until EOF, using multiple "
"calls to the stream if necessary."
msgstr ""
"Leer y devolver todos los *bytes* de la transmisión hasta llegar al fin del "
"archivo, usando, si es necesario, varias llamadas a la transmisión."

#: ../Doc/library/io.rst:426
msgid ""
"Read bytes into a pre-allocated, writable :term:`bytes-like object` *b*, and "
"return the number of bytes read.  For example, *b* might be a :class:"
"`bytearray`. If the object is in non-blocking mode and no bytes are "
"available, ``None`` is returned."
msgstr ""
"Leer *bytes* en objeto preasignado y grabable :term:`bytes-like object` *b*, "
"y devolver el número de *bytes* leído. Por ejemplo, *b* puede ser una clase "
"de tipo :class:`bytearray`. Si el objeto está en modo sin bloquear y no hay "
"*bytes* disponibles, se devuelve ``None``."

#: ../Doc/library/io.rst:434
msgid ""
"Write the given :term:`bytes-like object`, *b*, to the underlying raw "
"stream, and return the number of bytes written.  This can be less than the "
"length of *b* in bytes, depending on specifics of the underlying raw stream, "
"and especially if it is in non-blocking mode.  ``None`` is returned if the "
"raw stream is set not to block and no single byte could be readily written "
"to it.  The caller may release or mutate *b* after this method returns, so "
"the implementation should only access *b* during the method call."
msgstr ""
"Escribe :term:`bytes-like object` dado, *b*, a la transmisión subyacente y "
"devuelve la cantidad de *bytes* grabadas. Esto puede ser menos que la "
"longitud de *b* en *bytes*, dependiendo de la especificaciones de la "
"transmisión subyacente, especialmente si no está en modo no-bloqueo. "
"``None`` se devuelve si la transmisión sin formato está configurado para no "
"bloquear y ningún *byte* puede ser rapidamente grabada. El llamador puede "
"deshacer o mutar *b* después que devuelva este método, asi que la "
"implementación solo debería acceder *b* durante la ejecución al método."

#: ../Doc/library/io.rst:447
msgid ""
"Base class for binary streams that support some kind of buffering. It "
"inherits :class:`IOBase`. There is no public constructor."
msgstr ""
"Clase base para transmisiones binarios que apoyan algún tipo de búfer. "
"Hereda :class:`IOBase`. No hay constructor público."

#: ../Doc/library/io.rst:450
msgid ""
"The main difference with :class:`RawIOBase` is that methods :meth:`read`, :"
"meth:`readinto` and :meth:`write` will try (respectively) to read as much "
"input as requested or to consume all given output, at the expense of making "
"perhaps more than one system call."
msgstr ""
"La diferencia principal de :class:`RawIOBase` es que los métodos :meth:"
"`read`, :meth:`readinto` y :meth:`write` intenterán (respectivamente) leer "
"la cantidad de información solicitada o consumir toda la salida dada, a "
"expensas de hacer más de una llamada al sistema."

#: ../Doc/library/io.rst:455
msgid ""
"In addition, those methods can raise :exc:`BlockingIOError` if the "
"underlying raw stream is in non-blocking mode and cannot take or give enough "
"data; unlike their :class:`RawIOBase` counterparts, they will never return "
"``None``."
msgstr ""
"Adicionalmente, esos métodos pueden lanzar un :exc:`BlockingIOError` si la "
"transmisión sin formato subyacente está en modo no bloqueo y no puede "
"obtener or dar más datos; a diferencia de sus contrapartes :class:"
"`RawIOBase`, estos nunca devolverán ``None``."

#: ../Doc/library/io.rst:460
msgid ""
"Besides, the :meth:`read` method does not have a default implementation that "
"defers to :meth:`readinto`."
msgstr ""
"Además, el método :meth:`read` no tiene una implementación dada que difiere "
"al método :meth:`readinto`."

#: ../Doc/library/io.rst:463
msgid ""
"A typical :class:`BufferedIOBase` implementation should not inherit from a :"
"class:`RawIOBase` implementation, but wrap one, like :class:`BufferedWriter` "
"and :class:`BufferedReader` do."
msgstr ""
"Una implementación típica de :class:`BufferedIOBase` no debería heredar una "
"implementación de :class:`RawIOBase`, es más, debería envolver como uno, asi "
"como hacen las clases :class:`BufferedWriter` y :class:`BufferedReader`."

#: ../Doc/library/io.rst:467
msgid ""
":class:`BufferedIOBase` provides or overrides these methods and attribute in "
"addition to those from :class:`IOBase`:"
msgstr ""
":class:`BufferedIOBase` provee o anula estos métodos y atributos en adición "
"a los de :class:`IOBase`:"

#: ../Doc/library/io.rst:472
msgid ""
"The underlying raw stream (a :class:`RawIOBase` instance) that :class:"
"`BufferedIOBase` deals with.  This is not part of the :class:"
"`BufferedIOBase` API and may not exist on some implementations."
msgstr ""
"La transmisión sin formato subyacente ( una instancia :class:`RawIOBase`) "
"que :class:`BufferedIOBase` maneja. Esto no es parte de la API :class:"
"`BufferedIOBase` y posiblemente no exista en algunas implementaciones."

#: ../Doc/library/io.rst:478
msgid "Separate the underlying raw stream from the buffer and return it."
msgstr "Seperar la transmisión subyacente del búfer y devolver."

#: ../Doc/library/io.rst:480
msgid ""
"After the raw stream has been detached, the buffer is in an unusable state."
msgstr ""
"Luego que la transmisión sin formato ha sido separado, el búfer está en un "
"estado inutilizable."

#: ../Doc/library/io.rst:483
msgid ""
"Some buffers, like :class:`BytesIO`, do not have the concept of a single raw "
"stream to return from this method.  They raise :exc:`UnsupportedOperation`."
msgstr ""
"Algunos búfer, como :class:`BytesIO`, no tienen el concepto de una "
"transmisión sin formato singular para devolver de este método. Lanza un :exc:"
"`UnsupportedOperation`."

#: ../Doc/library/io.rst:491
msgid ""
"Read and return up to *size* bytes.  If the argument is omitted, ``None``, "
"or negative, data is read and returned until EOF is reached.  An empty :"
"class:`bytes` object is returned if the stream is already at EOF."
msgstr ""
"Leer y devolver hasta *size* en *bytes*. Si el argumento está omitido, "
"``None``, o es negativo, los datos son leídos y devueltos hasta que se "
"alcanze el fin del archivo. Un objeto :class:`bytes` vacío se devuelve si la "
"transmisión está al final del archivo."

#: ../Doc/library/io.rst:495
msgid ""
"If the argument is positive, and the underlying raw stream is not "
"interactive, multiple raw reads may be issued to satisfy the byte count "
"(unless EOF is reached first).  But for interactive raw streams, at most one "
"raw read will be issued, and a short result does not imply that EOF is "
"imminent."
msgstr ""
"Si el argumento es positivo, y la transmisión subyacente no es interactiva, "
"varias lecturas sin formato pueden ser otorgadas para satisfacer la cantidad "
"de *byte* (almenos que primero se llegue al fin del archivo). Pero para las "
"transmisiones sin formato interactivas, a lo sumo una lectura sin formato "
"será  emitida y un resultado corto no implica que se haya llegado al fin del "
"archivo."

#: ../Doc/library/io.rst:501 ../Doc/library/io.rst:524
#: ../Doc/library/io.rst:534
msgid ""
"A :exc:`BlockingIOError` is raised if the underlying raw stream is in non "
"blocking-mode, and has no data available at the moment."
msgstr ""
"Un :exc:`BlockingIOError` se lanza si la transmisión subyacente está en modo "
"no bloqueo y no tiene datos al momento."

#: ../Doc/library/io.rst:506
msgid ""
"Read and return up to *size* bytes, with at most one call to the underlying "
"raw stream's :meth:`~RawIOBase.read` (or :meth:`~RawIOBase.readinto`) "
"method.  This can be useful if you are implementing your own buffering on "
"top of a :class:`BufferedIOBase` object."
msgstr ""
"Leer y devolver hasta *size* en *bytes* con al menos una llamada al método :"
"meth:`~RawIOBase.read` (o :meth:`~RawIOBase.readinto`) de la transmisión "
"subyacente. Esto puede ser util si estás implementando tu propio búfer por "
"encima de un objeto :class:`BufferedIOBase`."

#: ../Doc/library/io.rst:512
msgid ""
"If *size* is ``-1`` (the default), an arbitrary number of bytes are returned "
"(more than zero unless EOF is reached)."
msgstr ""
"Si *size* es ``-1`` (el valor dado) se devuelve un monto arbitrario de "
"*bytes* (más que cero almenos que se haya llegado al fin del archivo)."

#: ../Doc/library/io.rst:517
msgid ""
"Read bytes into a pre-allocated, writable :term:`bytes-like object` *b* and "
"return the number of bytes read. For example, *b* might be a :class:"
"`bytearray`."
msgstr ""
"Leer *bytes* a un objeto predeterminado y grabable :term:`bytes-like object` "
"*b* y devolver el número de *bytes* leídos. Por ejemplo, *b* puede ser un :"
"class:`bytearray`."

#: ../Doc/library/io.rst:521
msgid ""
"Like :meth:`read`, multiple reads may be issued to the underlying raw "
"stream, unless the latter is interactive."
msgstr ""
"Como :meth:`read`, varias lecturas pueden ser otorgadas a la transmisión sin "
"formato subyacente almenos que esto último sea interactivo."

#: ../Doc/library/io.rst:529
msgid ""
"Read bytes into a pre-allocated, writable :term:`bytes-like object` *b*, "
"using at most one call to the underlying raw stream's :meth:`~RawIOBase."
"read` (or :meth:`~RawIOBase.readinto`) method. Return the number of bytes "
"read."
msgstr ""
"Leer *bytes* a un objeto predeterminado y grabable :term:`bytes-like object` "
"*b* usando por lo menos una llamada al método :meth:`~RawIOBase.read` (o :"
"meth:`~RawIOBase.readinto`) de la transmisión subyacente. Devuelve la "
"cantidad de *bytes* leídas."

#: ../Doc/library/io.rst:541
msgid ""
"Write the given :term:`bytes-like object`, *b*, and return the number of "
"bytes written (always equal to the length of *b* in bytes, since if the "
"write fails an :exc:`OSError` will be raised).  Depending on the actual "
"implementation, these bytes may be readily written to the underlying stream, "
"or held in a buffer for performance and latency reasons."
msgstr ""

#: ../Doc/library/io.rst:548
msgid ""
"When in non-blocking mode, a :exc:`BlockingIOError` is raised if the data "
"needed to be written to the raw stream but it couldn't accept all the data "
"without blocking."
msgstr ""
"Cuando estás en modo no bloqueo, se lanza un :exc:`BlockingIOError` si los "
"datos tenían que ser grabadas a la transmisión sin formato pero no pudo "
"aceptar todos los datos sin bloquear."

#: ../Doc/library/io.rst:552
msgid ""
"The caller may release or mutate *b* after this method returns, so the "
"implementation should only access *b* during the method call."
msgstr ""
"El llamador puede otorgar o mutar *b* después que este método devuelva algo, "
"entonces la implementación debería acceder solamente a *b* durante la "
"llamada al método."

#: ../Doc/library/io.rst:557
msgid "Raw File I/O"
msgstr "Archivo sin formato I/O"

#: ../Doc/library/io.rst:561
msgid ""
":class:`FileIO` represents an OS-level file containing bytes data. It "
"implements the :class:`RawIOBase` interface (and therefore the :class:"
"`IOBase` interface, too)."
msgstr ""
":class:`FileIO` representa un archivo de nivel OS conteniendo datos en "
"*bytes*. Implementa la interfaz :class:`RawIOBase` (y por ende también la "
"interfaz :class:`IOBase`)."

#: ../Doc/library/io.rst:565
msgid "The *name* can be one of two things:"
msgstr "El *name* puede ser una de dos cosas:"

#: ../Doc/library/io.rst:567
msgid ""
"a character string or :class:`bytes` object representing the path to the "
"file which will be opened. In this case closefd must be ``True`` (the "
"default) otherwise an error will be raised."
msgstr ""
"una cadena de caracteres u objeto de tipo :class:`bytes` representando la "
"ruta del archivo en la que fue abierto. En este caso closefd es ``True`` (el "
"valor dado) de otra manera un error será dada."

#: ../Doc/library/io.rst:570
msgid ""
"an integer representing the number of an existing OS-level file descriptor "
"to which the resulting :class:`FileIO` object will give access. When the "
"FileIO object is closed this fd will be closed as well, unless *closefd* is "
"set to ``False``."
msgstr ""
"un *integer* representando el número de descriptores de archivos de nivel OS "
"que resultan dando acceso a través del objeto :class:`FileIO`. Cuando el "
"objeto *FileIO* está cerrado este fd cerrará también a no ser que *closefd* "
"esté configurado a ``False``."

#: ../Doc/library/io.rst:575
msgid ""
"The *mode* can be ``'r'``, ``'w'``, ``'x'`` or ``'a'`` for reading "
"(default), writing, exclusive creation or appending. The file will be "
"created if it doesn't exist when opened for writing or appending; it will be "
"truncated when opened for writing. :exc:`FileExistsError` will be raised if "
"it already exists when opened for creating. Opening a file for creating "
"implies writing, so this mode behaves in a similar way to ``'w'``. Add a "
"``'+'`` to the mode to allow simultaneous reading and writing."
msgstr ""
"El *mode* puede ser ``’r’``, ``’w’``, ``’x’`` o``’a’`` para lectura (el "
"valor dado), grabación, creación exclusiva o anexando. Si no existe el "
"archivo se creará cuando se abra para grabar o anexar; se truncará cuando se "
"abra para grabar. Se lanzará un error :exc:`FileExistsError`   si ya existe "
"cuando se abra para crear. Abriendo un archivo para crear implica grabar "
"entonces este modo se compartar similarmente a ``’w’``. Agrega un ``’+’``  "
"al modo para permitir lectura y grabación simultáneas."

#: ../Doc/library/io.rst:583
msgid ""
"The :meth:`read` (when called with a positive argument), :meth:`readinto` "
"and :meth:`write` methods on this class will only make one system call."
msgstr ""
"Los métodos :meth:`read` (cuando se llama con un argumento positivo), :meth:"
"`readinto` y :meth:`write` en esta clase harán solo una llamada al sistema."

#: ../Doc/library/io.rst:586
msgid ""
"A custom opener can be used by passing a callable as *opener*. The "
"underlying file descriptor for the file object is then obtained by calling "
"*opener* with (*name*, *flags*). *opener* must return an open file "
"descriptor (passing :mod:`os.open` as *opener* results in functionality "
"similar to passing ``None``)."
msgstr ""
"Un abridor personalizado puede ser usado pasando un llamador como *opener*. "
"El descriptor de archivo subyacente es obtenido llamando *opener* con "
"(*name*, *flags*). *opener* debe devolver un descriptor de archivo abierto "
"(pasando :mod:`os.open` como *opener* resulta con funcionamiento similar a "
"pasando ``None``)."

#: ../Doc/library/io.rst:592
msgid "The newly created file is :ref:`non-inheritable <fd_inheritance>`."
msgstr "El archivo recién creado es :ref:`non-inheritable <fd_inheritance>`."

#: ../Doc/library/io.rst:594
msgid ""
"See the :func:`open` built-in function for examples on using the *opener* "
"parameter."
msgstr ""
"Ver la función incorporada :func:`open` para ejemplos usando el parámetro "
"*opener*."

#: ../Doc/library/io.rst:597
msgid "The *opener* parameter was added. The ``'x'`` mode was added."
msgstr "El parametro *opener* fue agregado. El modo ``’x’`` fue agregado."

#: ../Doc/library/io.rst:601
msgid "The file is now non-inheritable."
msgstr "El archivo ahora no es heredable."

#: ../Doc/library/io.rst:604
msgid ""
"In addition to the attributes and methods from :class:`IOBase` and :class:"
"`RawIOBase`, :class:`FileIO` provides the following data attributes:"
msgstr ""
"Además de los atributos y métodos de las clases :class:`IOBase` y :class:"
"`RawIOBase`, :class:`FileIO`, estos proveen los siguientes atributos:"

#: ../Doc/library/io.rst:610
msgid "The mode as given in the constructor."
msgstr "El modo dado en el constructor."

#: ../Doc/library/io.rst:614
msgid ""
"The file name.  This is the file descriptor of the file when no name is "
"given in the constructor."
msgstr ""
"El nombre del archivo. Este es el descriptor del archivo cuando no se "
"proporciona ningún nombre en el constructor."

#: ../Doc/library/io.rst:619
msgid "Buffered Streams"
msgstr "Transmisiones almacenadas (búfer)."

#: ../Doc/library/io.rst:621
msgid ""
"Buffered I/O streams provide a higher-level interface to an I/O device than "
"raw I/O does."
msgstr ""
"Transmisiones I/O almacenadas (búfer) proveen una interfaz de más alto nivel "
"a un dispositivo I/O que a un I/O sin formato."

#: ../Doc/library/io.rst:626
msgid ""
"A stream implementation using an in-memory bytes buffer.  It inherits :class:"
"`BufferedIOBase`.  The buffer is discarded when the :meth:`~IOBase.close` "
"method is called."
msgstr ""
"Una implementación de transmisión usando búferes de *bytes* en memoria. "
"Hereda :class:`BufferedIOBase`.  El búfer está descartado cuando se llama al "
"método :meth:`~IOBase.close`."

#: ../Doc/library/io.rst:630
msgid ""
"The optional argument *initial_bytes* is a :term:`bytes-like object` that "
"contains initial data."
msgstr ""
"El argumento opcional *initial_bytes* es un :term:`bytes-like object` que "
"contiene datos iniciales."

#: ../Doc/library/io.rst:633
msgid ""
":class:`BytesIO` provides or overrides these methods in addition to those "
"from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""
":class:`BytesIO` provee o anula estos métodos además de los de :class:"
"`BufferedIOBase` y :class:`IOBase`:"

#: ../Doc/library/io.rst:638
msgid ""
"Return a readable and writable view over the contents of the buffer without "
"copying them.  Also, mutating the view will transparently update the "
"contents of the buffer::"
msgstr ""
"Devolver una vista legible y grabable acerca de los contenidos del búfer sin "
"copiarlos. Además mutando la vista actualizará de forma transparaente los "
"contenidos del búfer::"

#: ../Doc/library/io.rst:649
msgid ""
"As long as the view exists, the :class:`BytesIO` object cannot be resized or "
"closed."
msgstr ""
"Mientras exista la vista el objeto :class:`BytesIO` no se le puede cambiar "
"el tamaño o cerrado."

#: ../Doc/library/io.rst:656
msgid "Return :class:`bytes` containing the entire contents of the buffer."
msgstr "Devolver :class:`bytes` que contiene los contenidos enteros del búfer."

#: ../Doc/library/io.rst:661
msgid "In :class:`BytesIO`, this is the same as :meth:`~BufferedIOBase.read`."
msgstr ""
"En la clase :class:`BytesIO` esto es lo mismo que :meth:`~BufferedIOBase."
"read`."

#: ../Doc/library/io.rst:663 ../Doc/library/io.rst:704
msgid "The *size* argument is now optional."
msgstr "Ahora es opcional el argumento *size*."

#: ../Doc/library/io.rst:668
msgid ""
"In :class:`BytesIO`, this is the same as :meth:`~BufferedIOBase.readinto`."
msgstr ""
"En la clase :class:`BytesIO` esto es lo mismo que :meth:`~BufferedIOBase."
"readinto`."

#: ../Doc/library/io.rst:674
msgid ""
"A buffer providing higher-level access to a readable, sequential :class:"
"`RawIOBase` object.  It inherits :class:`BufferedIOBase`. When reading data "
"from this object, a larger amount of data may be requested from the "
"underlying raw stream, and kept in an internal buffer. The buffered data can "
"then be returned directly on subsequent reads."
msgstr ""
"Un búfer proprocionando un nivel de alto acceso a un objeto  :class:"
"`RawIOBase` legible y sequencial. Hereda :class:`BufferedIOBase`. Al leer "
"datos de este objeto se puede solicitar una mayor cantidad de datos de la "
"transmisión sin formato subyacente, y mantener el búfer interno. Los datos "
"que han pasado por el proceso de búfer pueden ser devueltos directamente en "
"lecturas posteriores."

#: ../Doc/library/io.rst:680
msgid ""
"The constructor creates a :class:`BufferedReader` for the given readable "
"*raw* stream and *buffer_size*.  If *buffer_size* is omitted, :data:"
"`DEFAULT_BUFFER_SIZE` is used."
msgstr ""
"El constructor crea un :class:`BufferedReader` para la legible transmisión "
"sin formato *raw* y *buffer_size*. Si se omite *buffer_size* se usa :data:"
"`DEFAULT_BUFFER_SIZE`."

#: ../Doc/library/io.rst:684
msgid ""
":class:`BufferedReader` provides or overrides these methods in addition to "
"those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""
":class:`BufferedReader` provee o anula los métodos en adición a los de :"
"class:`BufferedIOBase` y :class:`IOBase`:"

#: ../Doc/library/io.rst:689
msgid ""
"Return bytes from the stream without advancing the position.  At most one "
"single read on the raw stream is done to satisfy the call. The number of "
"bytes returned may be less or more than requested."
msgstr ""
"Devolver *bytes* de la transmisión sin avanzar la posición. Al menos una "
"lectura se hace a la transmisión sin formato para satisfacer el llamado. El "
"número de bytes devueltos puede ser menor o mayor al solicitado."

#: ../Doc/library/io.rst:695
msgid ""
"Read and return *size* bytes, or if *size* is not given or negative, until "
"EOF or if the read call would block in non-blocking mode."
msgstr ""
"Leer y devolver *size* *bytes* o si no se da *size*, o es negativo, hasta el "
"fin del archivo o si la llamada leída podría bloquear in modo no bloquear. "

#: ../Doc/library/io.rst:700
msgid ""
"Read and return up to *size* bytes with only one call on the raw stream. If "
"at least one byte is buffered, only buffered bytes are returned. Otherwise, "
"one raw stream read call is made."
msgstr ""
"Leer y devolver hasta el tamaño *size* en *bytes* con solo una llamada a la "
"transmisión. Si al menos un *byte* pasa por el proceso de búfer, solo se "
"devuelven *buffered bytes*. De lo contrario se realize una llamada de "
"lectura de transmisión sin formato. "

#: ../Doc/library/io.rst:710
msgid ""
"A buffer providing higher-level access to a writeable, sequential :class:"
"`RawIOBase` object.  It inherits :class:`BufferedIOBase`. When writing to "
"this object, data is normally placed into an internal buffer.  The buffer "
"will be written out to the underlying :class:`RawIOBase` object under "
"various conditions, including:"
msgstr ""
"Un búfer que proporciona un nivel alto de acceso a un objeto  :class:"
"`RawIOBase` grabable y secuencial. Hereda :class:`BufferedIOBase`. Al "
"escribir a este objeto, los datos normalmente se colocan en un búfer "
"interno. El búfer se escribirá en el objeto :class:`RawIOBase` subyacente "
"bajo varias condiciones, incluyendo:"

#: ../Doc/library/io.rst:716
msgid "when the buffer gets too small for all pending data;"
msgstr ""
"cuando el búfer se vuelve demasiado pequeño para todos los datos pendientes;"

#: ../Doc/library/io.rst:717
msgid "when :meth:`flush()` is called;"
msgstr "cuando se llama :meth:`flush()`;"

#: ../Doc/library/io.rst:718
msgid ""
"when a :meth:`seek()` is requested (for :class:`BufferedRandom` objects);"
msgstr ""
"cuando se pide un método :meth:`seek()` (para :class:`BufferedRandom` "
"objects);"

#: ../Doc/library/io.rst:719
msgid "when the :class:`BufferedWriter` object is closed or destroyed."
msgstr "cuando el objeto :class:`BufferedWriter` is cerrado o anulado. "

#: ../Doc/library/io.rst:721
msgid ""
"The constructor creates a :class:`BufferedWriter` for the given writeable "
"*raw* stream.  If the *buffer_size* is not given, it defaults to :data:"
"`DEFAULT_BUFFER_SIZE`."
msgstr ""
"El constructor crea un :class:`BufferedWriter` para la transmisión grabable "
"*raw*. Si nos dado el *buffer_size*, recurre el valor :data:"
"`DEFAULT_BUFFER_SIZE`."

#: ../Doc/library/io.rst:725
msgid ""
":class:`BufferedWriter` provides or overrides these methods in addition to "
"those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""
":class:`BufferedWriter` provee o anula estos métodos además de los de :class:"
"`BufferedIOBase` y :class:`IOBase`:"

#: ../Doc/library/io.rst:730
msgid ""
"Force bytes held in the buffer into the raw stream.  A :exc:"
"`BlockingIOError` should be raised if the raw stream blocks."
msgstr ""
"Forzar bytes retenidos en el búfer a la transmisión sin formato. Un :exc:"
"`BlockingIOError` debería ser lanzado si la transmisión sin formato bloquea. "

#: ../Doc/library/io.rst:735
msgid ""
"Write the :term:`bytes-like object`, *b*, and return the number of bytes "
"written.  When in non-blocking mode, a :exc:`BlockingIOError` is raised if "
"the buffer needs to be written out but the raw stream blocks."
msgstr ""
"Escribe el :term:`bytes-like object`, *b*, y devuelve el número de bytes "
"grabados. Cuando estás en modo no-bloqueo, se lanza un :exc:"
"`BlockingIOError` si el búfer tiene que ser escrito pero la transmisión sin "
"formato bloquea. "

#: ../Doc/library/io.rst:743
msgid ""
"A buffered interface to random access streams.  It inherits :class:"
"`BufferedReader` and :class:`BufferedWriter`."
msgstr ""
"Una interfaz búfer para transmisiones de acceso aleatorio. Hereda :class:"
"`BufferedReader` y :class:`BufferedWriter`."

#: ../Doc/library/io.rst:746
msgid ""
"The constructor creates a reader and writer for a seekable raw stream, given "
"in the first argument.  If the *buffer_size* is omitted it defaults to :data:"
"`DEFAULT_BUFFER_SIZE`."
msgstr ""
"El constructor crea un lector y una grabación para una transmisión sin "
"formato buscable, dado en el primer argumento. Si se omite el *buffer_size* "
"este recae sobre el valor predeterminado :data:`DEFAULT_BUFFER_SIZE`."

#: ../Doc/library/io.rst:750
msgid ""
":class:`BufferedRandom` is capable of anything :class:`BufferedReader` or :"
"class:`BufferedWriter` can do.  In addition, :meth:`seek` and :meth:`tell` "
"are guaranteed to be implemented."
msgstr ""
":class:`BufferedRandom` es capaz de todo lo que puede hacer :class:"
"`BufferedReader` o :class:`BufferedWriter`. Adicionalmente, se grantiza "
"implementar :meth:`seek` y :meth:`tell`."

#: ../Doc/library/io.rst:757
msgid ""
"A buffered I/O object combining two unidirectional :class:`RawIOBase` "
"objects -- one readable, the other writeable -- into a single bidirectional "
"endpoint.  It inherits :class:`BufferedIOBase`."
msgstr ""
"Un objeto bufer I/O combinando dos objetos :class:`RawIOBase` "
"unidireccionales — uno legible y el otro escribible — a un punto final "
"singular bidireccional. Hereda :class:`BufferedIOBase`."

#: ../Doc/library/io.rst:761
msgid ""
"*reader* and *writer* are :class:`RawIOBase` objects that are readable and "
"writeable respectively.  If the *buffer_size* is omitted it defaults to :"
"data:`DEFAULT_BUFFER_SIZE`."
msgstr ""
"*reader* y *writer* son objetos :class:`RawIOBase` que son respectivamente "
"legibles y escribibles. Si se omite *buffer_size* este se recae sobre el "
"valor predeterminado :data:`DEFAULT_BUFFER_SIZE`."

#: ../Doc/library/io.rst:765
msgid ""
":class:`BufferedRWPair` implements all of :class:`BufferedIOBase`\\'s "
"methods except for :meth:`~BufferedIOBase.detach`, which raises :exc:"
"`UnsupportedOperation`."
msgstr ""
":class:`BufferedRWPair` implementa todos los métodos de :class:"
"`BufferedIOBase` excepto por :meth:`~BufferedIOBase.detach`, que lanza un :"
"exc:`UnsupportedOperation`."

#: ../Doc/library/io.rst:771
msgid ""
":class:`BufferedRWPair` does not attempt to synchronize accesses to its "
"underlying raw streams.  You should not pass it the same object as reader "
"and writer; use :class:`BufferedRandom` instead."
msgstr ""
":class:`BufferedRWPair` no intenta sincronizar accesos a la transmisión sin "
"formato subyacente. No debes pasar el mismo objeto como legible y "
"escribible; usa :class:`BufferedRandom` en su lugar."

#: ../Doc/library/io.rst:781
msgid ""
"Base class for text streams.  This class provides a character and line based "
"interface to stream I/O.  It inherits :class:`IOBase`. There is no public "
"constructor."
msgstr ""
"Clase base para las transmisiones de tipo text. Esta clase proporciona una "
"interfaz basada en caracteres y líneas para transmitir I/O. Hereda :class:"
"`IOBase`. No hay constructor público."

#: ../Doc/library/io.rst:785
msgid ""
":class:`TextIOBase` provides or overrides these data attributes and methods "
"in addition to those from :class:`IOBase`:"
msgstr ""
":class:`TextIOBase` provee o anula estos atributos y métodos de datos además "
"de los de :class:`IOBase`:"

#: ../Doc/library/io.rst:790
msgid ""
"The name of the encoding used to decode the stream's bytes into strings, and "
"to encode strings into bytes."
msgstr ""
"El nombre de la codificación utilizada para decodificar los *bytes* de la "
"transmisión a cadenas de caracteres y para codificar cadenas de caracteres "
"en bytes."

#: ../Doc/library/io.rst:795
msgid "The error setting of the decoder or encoder."
msgstr "La configuración de error del decodificador o codificador."

#: ../Doc/library/io.rst:799
msgid ""
"A string, a tuple of strings, or ``None``, indicating the newlines "
"translated so far.  Depending on the implementation and the initial "
"constructor flags, this may not be available."
msgstr ""
"una cadena de cracteres, una tupla de cadenda de caracteres, o ``None``, "
"indicando las nuevas líneas traducidas hasta ese momento. Dependiendo de la "
"implementación y los indicadores iniciales del constructor, esto puede no "
"estar disponible."

#: ../Doc/library/io.rst:805
msgid ""
"The underlying binary buffer (a :class:`BufferedIOBase` instance) that :"
"class:`TextIOBase` deals with.  This is not part of the :class:`TextIOBase` "
"API and may not exist in some implementations."
msgstr ""
"El búfer binario subyacente (una instancia :class:`BufferedIOBase`) que "
"maneja :class:`TextIOBase`. Esto no es parte del API de :class:`TextIOBase` "
"y puede no existir en algunas implementaciones."

#: ../Doc/library/io.rst:811
msgid ""
"Separate the underlying binary buffer from the :class:`TextIOBase` and "
"return it."
msgstr ""
"Separar el búfer binario subyacente de: class: `TextIOBase` y devolverlo."

#: ../Doc/library/io.rst:814
msgid ""
"After the underlying buffer has been detached, the :class:`TextIOBase` is in "
"an unusable state."
msgstr ""
"Una vez que se ha separado el búfer subyacente, la :class:`TextIOBase` está "
"en un estado inutilizable."

#: ../Doc/library/io.rst:817
msgid ""
"Some :class:`TextIOBase` implementations, like :class:`StringIO`, may not "
"have the concept of an underlying buffer and calling this method will raise :"
"exc:`UnsupportedOperation`."
msgstr ""
"Algunas implementaciones de :class:`TextIOBase`, como :class:`StringIO`, "
"puede no tener el concepto de un búfer subyacente y llamar a este método se "
"lanzará :exc:`UnsupportedOperation`. "

#: ../Doc/library/io.rst:825
msgid ""
"Read and return at most *size* characters from the stream as a single :class:"
"`str`.  If *size* is negative or ``None``, reads until EOF."
msgstr ""
"Leer y devolver como máximo *size* caracteres de la transmisión como un :"
"class:`str` singular. Si *size* es negativo o ``None``, lee hasta llegar al "
"fin del archivo."

#: ../Doc/library/io.rst:830
msgid ""
"Read until newline or EOF and return a single ``str``.  If the stream is "
"already at EOF, an empty string is returned."
msgstr ""
"Leer hasta la nueva línea o fin del archivo y devolver un ``str`` singular. "
"Si la transmisión está al fin del archivo una cadena de caracteres se "
"devuelve."

#: ../Doc/library/io.rst:833
msgid "If *size* is specified, at most *size* characters will be read."
msgstr "Si se especifica *size* como máximo *size* de caracteres será leído."

#: ../Doc/library/io.rst:837
msgid ""
"Change the stream position to the given *offset*.  Behaviour depends on the "
"*whence* parameter.  The default value for *whence* is :data:`SEEK_SET`."
msgstr ""

#: ../Doc/library/io.rst:841
msgid ""
":data:`SEEK_SET` or ``0``: seek from the start of the stream (the default); "
"*offset* must either be a number returned by :meth:`TextIOBase.tell`, or "
"zero.  Any other *offset* value produces undefined behaviour."
msgstr ""

#: ../Doc/library/io.rst:845
msgid ""
":data:`SEEK_CUR` or ``1``: \"seek\" to the current position; *offset* must "
"be zero, which is a no-operation (all other values are unsupported)."
msgstr ""

#: ../Doc/library/io.rst:848
msgid ""
":data:`SEEK_END` or ``2``: seek to the end of the stream; *offset* must be "
"zero (all other values are unsupported)."
msgstr ""

#: ../Doc/library/io.rst:851
msgid "Return the new absolute position as an opaque number."
msgstr ""

#: ../Doc/library/io.rst:858
msgid ""
"Return the current stream position as an opaque number.  The number does not "
"usually represent a number of bytes in the underlying binary storage."
msgstr ""

#: ../Doc/library/io.rst:864
msgid ""
"Write the string *s* to the stream and return the number of characters "
"written."
msgstr ""

#: ../Doc/library/io.rst:871
msgid ""
"A buffered text stream over a :class:`BufferedIOBase` binary stream. It "
"inherits :class:`TextIOBase`."
msgstr ""

#: ../Doc/library/io.rst:874
msgid ""
"*encoding* gives the name of the encoding that the stream will be decoded or "
"encoded with.  It defaults to :func:`locale.getpreferredencoding(False) "
"<locale.getpreferredencoding>`."
msgstr ""

#: ../Doc/library/io.rst:878
msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handled.  Pass ``'strict'`` to raise a :exc:`ValueError` "
"exception if there is an encoding error (the default of ``None`` has the "
"same effect), or pass ``'ignore'`` to ignore errors.  (Note that ignoring "
"encoding errors can lead to data loss.)  ``'replace'`` causes a replacement "
"marker (such as ``'?'``) to be inserted where there is malformed data. "
"``'backslashreplace'`` causes malformed data to be replaced by a backslashed "
"escape sequence.  When writing, ``'xmlcharrefreplace'`` (replace with the "
"appropriate XML character reference)  or ``'namereplace'`` (replace with ``"
"\\N{...}`` escape sequences) can be used.  Any other error handling name "
"that has been registered with :func:`codecs.register_error` is also valid."
msgstr ""

#: ../Doc/library/io.rst:894
msgid ""
"*newline* controls how line endings are handled.  It can be ``None``, "
"``''``, ``'\\n'``, ``'\\r'``, and ``'\\r\\n'``.  It works as follows:"
msgstr ""

#: ../Doc/library/io.rst:897
msgid ""
"When reading input from the stream, if *newline* is ``None``, :term:"
"`universal newlines` mode is enabled.  Lines in the input can end in "
"``'\\n'``, ``'\\r'``, or ``'\\r\\n'``, and these are translated into "
"``'\\n'`` before being returned to the caller.  If it is ``''``, universal "
"newlines mode is enabled, but line endings are returned to the caller "
"untranslated. If it has any of the other legal values, input lines are only "
"terminated by the given string, and the line ending is returned to the "
"caller untranslated."
msgstr ""

#: ../Doc/library/io.rst:906
msgid ""
"When writing output to the stream, if *newline* is ``None``, any ``'\\n'`` "
"characters written are translated to the system default line separator, :"
"data:`os.linesep`.  If *newline* is ``''`` or ``'\\n'``, no translation "
"takes place.  If *newline* is any of the other legal values, any ``'\\n'`` "
"characters written are translated to the given string."
msgstr ""

#: ../Doc/library/io.rst:912
msgid ""
"If *line_buffering* is ``True``, :meth:`flush` is implied when a call to "
"write contains a newline character or a carriage return."
msgstr ""

#: ../Doc/library/io.rst:915
msgid ""
"If *write_through* is ``True``, calls to :meth:`write` are guaranteed not to "
"be buffered: any data written on the :class:`TextIOWrapper` object is "
"immediately handled to its underlying binary *buffer*."
msgstr ""

#: ../Doc/library/io.rst:919
msgid "The *write_through* argument has been added."
msgstr ""

#: ../Doc/library/io.rst:922
msgid ""
"The default *encoding* is now ``locale.getpreferredencoding(False)`` instead "
"of ``locale.getpreferredencoding()``. Don't change temporary the locale "
"encoding using :func:`locale.setlocale`, use the current locale encoding "
"instead of the user preferred encoding."
msgstr ""

#: ../Doc/library/io.rst:928
msgid ""
":class:`TextIOWrapper` provides these members in addition to those of :class:"
"`TextIOBase` and its parents:"
msgstr ""

#: ../Doc/library/io.rst:933
msgid "Whether line buffering is enabled."
msgstr ""

#: ../Doc/library/io.rst:937
msgid "Whether writes are passed immediately to the underlying binary buffer."
msgstr ""

#: ../Doc/library/io.rst:945
msgid ""
"Reconfigure this text stream using new settings for *encoding*, *errors*, "
"*newline*, *line_buffering* and *write_through*."
msgstr ""

#: ../Doc/library/io.rst:948
msgid ""
"Parameters not specified keep current settings, except ``errors='strict'`` "
"is used when *encoding* is specified but *errors* is not specified."
msgstr ""

#: ../Doc/library/io.rst:952
msgid ""
"It is not possible to change the encoding or newline if some data has "
"already been read from the stream. On the other hand, changing encoding "
"after write is possible."
msgstr ""

#: ../Doc/library/io.rst:956
msgid ""
"This method does an implicit stream flush before setting the new parameters."
msgstr ""

#: ../Doc/library/io.rst:964
msgid ""
"An in-memory stream for text I/O.  The text buffer is discarded when the :"
"meth:`~IOBase.close` method is called."
msgstr ""

#: ../Doc/library/io.rst:967
msgid ""
"The initial value of the buffer can be set by providing *initial_value*. If "
"newline translation is enabled, newlines will be encoded as if by :meth:"
"`~TextIOBase.write`.  The stream is positioned at the start of the buffer."
msgstr ""

#: ../Doc/library/io.rst:972
msgid ""
"The *newline* argument works like that of :class:`TextIOWrapper`. The "
"default is to consider only ``\\n`` characters as ends of lines and to do no "
"newline translation.  If *newline* is set to ``None``, newlines are written "
"as ``\\n`` on all platforms, but universal newline decoding is still "
"performed when reading."
msgstr ""

#: ../Doc/library/io.rst:978
msgid ""
":class:`StringIO` provides this method in addition to those from :class:"
"`TextIOBase` and its parents:"
msgstr ""

#: ../Doc/library/io.rst:983
msgid ""
"Return a ``str`` containing the entire contents of the buffer. Newlines are "
"decoded as if by :meth:`~TextIOBase.read`, although the stream position is "
"not changed."
msgstr ""

#: ../Doc/library/io.rst:987
msgid "Example usage::"
msgstr "Ejemplos de uso::"

#: ../Doc/library/io.rst:1009
msgid ""
"A helper codec that decodes newlines for :term:`universal newlines` mode. It "
"inherits :class:`codecs.IncrementalDecoder`."
msgstr ""

#: ../Doc/library/io.rst:1014
msgid "Performance"
msgstr ""

#: ../Doc/library/io.rst:1016
msgid ""
"This section discusses the performance of the provided concrete I/O "
"implementations."
msgstr ""

#: ../Doc/library/io.rst:1022
msgid ""
"By reading and writing only large chunks of data even when the user asks for "
"a single byte, buffered I/O hides any inefficiency in calling and executing "
"the operating system's unbuffered I/O routines.  The gain depends on the OS "
"and the kind of I/O which is performed.  For example, on some modern OSes "
"such as Linux, unbuffered disk I/O can be as fast as buffered I/O.  The "
"bottom line, however, is that buffered I/O offers predictable performance "
"regardless of the platform and the backing device.  Therefore, it is almost "
"always preferable to use buffered I/O rather than unbuffered I/O for binary "
"data."
msgstr ""

#: ../Doc/library/io.rst:1034
msgid ""
"Text I/O over a binary storage (such as a file) is significantly slower than "
"binary I/O over the same storage, because it requires conversions between "
"unicode and binary data using a character codec.  This can become noticeable "
"handling huge amounts of text data like large log files.  Also, :meth:"
"`TextIOWrapper.tell` and :meth:`TextIOWrapper.seek` are both quite slow due "
"to the reconstruction algorithm used."
msgstr ""

#: ../Doc/library/io.rst:1041
msgid ""
":class:`StringIO`, however, is a native in-memory unicode container and will "
"exhibit similar speed to :class:`BytesIO`."
msgstr ""

#: ../Doc/library/io.rst:1045
msgid "Multi-threading"
msgstr ""

#: ../Doc/library/io.rst:1047
msgid ""
":class:`FileIO` objects are thread-safe to the extent that the operating "
"system calls (such as ``read(2)`` under Unix) they wrap are thread-safe too."
msgstr ""

#: ../Doc/library/io.rst:1050
msgid ""
"Binary buffered objects (instances of :class:`BufferedReader`, :class:"
"`BufferedWriter`, :class:`BufferedRandom` and :class:`BufferedRWPair`) "
"protect their internal structures using a lock; it is therefore safe to call "
"them from multiple threads at once."
msgstr ""

#: ../Doc/library/io.rst:1055
msgid ":class:`TextIOWrapper` objects are not thread-safe."
msgstr ""

#: ../Doc/library/io.rst:1058
msgid "Reentrancy"
msgstr ""

#: ../Doc/library/io.rst:1060
msgid ""
"Binary buffered objects (instances of :class:`BufferedReader`, :class:"
"`BufferedWriter`, :class:`BufferedRandom` and :class:`BufferedRWPair`) are "
"not reentrant.  While reentrant calls will not happen in normal situations, "
"they can arise from doing I/O in a :mod:`signal` handler.  If a thread tries "
"to re-enter a buffered object which it is already accessing, a :exc:"
"`RuntimeError` is raised.  Note this doesn't prohibit a different thread "
"from entering the buffered object."
msgstr ""

#: ../Doc/library/io.rst:1068
msgid ""
"The above implicitly extends to text files, since the :func:`open()` "
"function will wrap a buffered object inside a :class:`TextIOWrapper`.  This "
"includes standard streams and therefore affects the built-in function :func:"
"`print()` as well."
msgstr ""
